# Chapter 2：AI × Data 系統藍圖

> **本章定位**：系統全景圖。讓你看到一個完整 AI 系統的骨架，理解每一層在做什麼。
>
> 「看不到全貌的人，只能解決局部問題。」

---

## 先看全貌

在學任何細節之前，先把整張圖印在腦子裡。

```
┌─────────────────────────────────────────────────────┐
│                     User Layer                       │
│          (人類使用者 / 前端介面 / API 消費者)          │
└──────────────────────┬──────────────────────────────┘
                       │ 請求
                       ▼
┌─────────────────────────────────────────────────────┐
│               Agent Orchestrator                     │
│    (AI 代理人協調器 — 系統的大腦和交通指揮官)           │
│                                                       │
│    ┌──────────┐ ┌──────────┐ ┌──────────────────┐   │
│    │ Planner  │ │ Executor │ │ Response Builder  │   │
│    │ 計畫器    │ │ 執行器   │ │ 回應組裝器        │   │
│    └──────────┘ └──────────┘ └──────────────────┘   │
└────┬──────────────────┬──────────────────┬──────────┘
     │                  │                  │
     ▼                  ▼                  ▼
┌─────────┐    ┌──────────────┐    ┌──────────────┐
│   RAG   │    │  MCP Tools   │    │  Automation   │
│ 知識檢索 │    │  工具呼叫     │    │  自動化流程    │
└────┬────┘    └──────┬───────┘    └──────┬───────┘
     │                │                    │
     ▼                ▼                    ▼
┌─────────────────────────────────────────────────────┐
│                  Data Layer                           │
│                                                       │
│    ┌──────┐  ┌──────┐  ┌──────┐  ┌──────────────┐  │
│    │  DB  │  │  KB  │  │ KPI  │  │    Logs      │  │
│    │ 資料庫│  │知識庫 │  │ 指標 │  │   日誌紀錄    │  │
│    └──────┘  └──────┘  └──────┘  └──────────────┘  │
└─────────────────────────────────────────────────────┘
```

這就是你要設計的系統。接下來我們逐層拆解。

---

## Layer 1：User Layer（使用者層）

### 這層在做什麼？

使用者層是「系統的入口」。它負責：

```
1. 接收使用者的請求（問題、指令、查詢）
2. 將請求標準化（格式統一、語言偵測）
3. 驗證身份和權限
4. 顯示結果給使用者
```

### 類比

使用者層就像飯店的**大廳接待**：
- 確認你有訂房（身份驗證）
- 問你需要什麼服務（請求解析）
- 引導你去正確的地方（路由）
- 不會讓你直接進廚房（權限控制）

### 設計原則

```
原則                 說明                           反面教材
──────              ──────                         ──────
輸入驗證             所有輸入都要驗證                 直接把使用者輸入丟給 AI
權限檢查             先確認身份再處理                 所有人都能存取所有功能
請求標準化           統一格式再往下傳                 每層各自解析原始輸入
優雅錯誤處理         錯誤訊息要對人類友善              回傳 500 Internal Error
```

### 這層 **不該** 做什麼

```
❌ 直接存取資料庫
❌ 包含業務邏輯
❌ 決定 AI 的回答策略
❌ 儲存敏感資料在前端
```

---

## Layer 2：Agent Orchestrator（代理人協調器）

### 這層在做什麼？

這是系統的大腦。它負責：

```
1. Planner（計畫器）
   → 分析使用者的意圖
   → 決定需要哪些工具和資料
   → 制定執行計畫

2. Executor（執行器）
   → 按照計畫呼叫工具
   → 處理工具回傳的結果
   → 處理失敗和重試

3. Response Builder（回應組裝器）
   → 將多個來源的結果整合
   → 加上 citation（引用來源）
   → 格式化最終回應
```

### 類比

協調器就像餐廳的**主廚**：
- 看到點單（使用者請求）
- 分配任務給廚師們（工具呼叫）
- 確認每道菜的品質（結果驗證）
- 組合成一份完整的套餐（回應組裝）

### 執行流程詳解

```
使用者問：「上個月的客戶流失率是多少？跟前一個月比如何？」

Step 1 - Planner 分析意圖：
  意圖：查詢 KPI（客戶流失率）
  時間範圍：上個月 + 前一個月
  操作類型：比較分析
  需要工具：db.kpi()
  需要資料：churn_rate 近兩個月

Step 2 - Executor 執行：
  呼叫 1：db.kpi("churn_rate", period="2025-12")
  結果 1：{ value: 5.2, unit: "%", period: "2025-12" }

  呼叫 2：db.kpi("churn_rate", period="2025-11")
  結果 2：{ value: 4.8, unit: "%", period: "2025-11" }

Step 3 - Response Builder 組裝：
  「上個月（2025-12）的客戶流失率為 5.2%，
   前一個月（2025-11）為 4.8%，
   月增 0.4 個百分點（+8.3%）。
   [來源：db.kpi("churn_rate")]」
```

### 設計原則

| 原則 | 說明 | 為什麼重要 |
|------|------|-----------|
| 單一職責 | Planner、Executor、Response Builder 各司其職 | 容易除錯和維護 |
| 失敗隔離 | 一個工具失敗不影響其他工具 | 系統韌性 |
| 計畫可見 | 執行計畫要記錄在日誌中 | 可追溯性 |
| 冪等性 | 同一個請求重複執行結果相同 | 可靠性 |

---

## Layer 3：三大服務支柱

### 支柱一：RAG（檢索增強生成）

```
角色：系統的「記憶」和「知識庫」

工作流程：
  使用者問題
    → Embedding（向量化）
    → 向量搜尋（找到相關文件）
    → Chunk 提取（取出相關段落）
    → 注入 Context（給 AI 參考）
    → 生成回答（附帶引用）

關鍵設計點：
  ✓ 每個回答都要有 citation
  ✓ 文件要有版本控制
  ✓ Chunk 策略影響回答品質
  ✓ 要能偵測「找不到答案」的情況
```

**詳細設計請見** → [Chapter 5：可治理 RAG 設計](05-rag-architecture.md)

### 支柱二：MCP Tools（工具呼叫）

```
角色：系統的「手」— 執行具體操作

工具類型：
  查詢工具：db.query(), db.kpi()     → 只讀，低風險
  分析工具：analytics.trend()         → 只讀，中風險
  操作工具：ticket.create()           → 寫入，高風險
  通知工具：notify.send()             → 外部效果，高風險

關鍵設計點：
  ✓ 每個工具有明確的 input/output schema
  ✓ 工具有權限等級和風險等級
  ✓ 所有工具呼叫都有日誌
  ✓ 寫入操作需要人工審核
```

**詳細設計請見** → [Chapter 4：MCP Tool Contract 標準](04-tool-contracts.md)

### 支柱三：Automation（自動化流程）

```
角色：系統的「自動導航」— 處理例行性工作

典型流程：
  流程 1：問題 → 查詢 → 報告 → 通知
  流程 2：KB 更新 → 重建索引 → 版本標記
  流程 3：KPI 異常 → 觸發分析 → 建立工單

關鍵設計點：
  ✓ 自動化不等於無監督
  ✓ 每個流程有觸發條件和終止條件
  ✓ 異常時要回退到人工處理
  ✓ 流程執行有完整日誌
```

**詳細設計請見** → [Chapter 7：自動化流程模式庫](07-automation-patterns.md)

---

## Layer 4：Data Layer（資料層）

### 四大資料存儲

```
┌──────────────────────────────────────────────────┐
│                   Data Layer                      │
│                                                    │
│  ┌────────────────┐    ┌────────────────────┐    │
│  │ DB（資料庫）    │    │ KB（知識庫）         │    │
│  │                 │    │                     │    │
│  │ 結構化業務資料   │    │ 非結構化文件         │    │
│  │ 交易紀錄        │    │ SOP、政策、手冊      │    │
│  │ 用戶資料        │    │ PDF、Markdown        │    │
│  │ 產品目錄        │    │ 向量索引             │    │
│  └────────────────┘    └────────────────────┘    │
│                                                    │
│  ┌────────────────┐    ┌────────────────────┐    │
│  │ KPI（指標庫）   │    │ Logs（日誌庫）       │    │
│  │                 │    │                     │    │
│  │ 業務指標定義     │    │ 操作紀錄             │    │
│  │ 計算公式        │    │ 工具呼叫紀錄         │    │
│  │ 閾值設定        │    │ 錯誤紀錄             │    │
│  │ 歷史趨勢        │    │ 成本紀錄             │    │
│  └────────────────┘    └────────────────────┘    │
└──────────────────────────────────────────────────┘
```

### 每種存儲的責任邊界

| 存儲 | 存什麼 | 不存什麼 | 誰能讀 | 誰能寫 |
|------|--------|----------|--------|--------|
| DB | 業務資料 | 文件內容 | Agent (readonly) | 應用程式 |
| KB | 知識文件 | 交易資料 | RAG 服務 | 管理員 |
| KPI | 指標定義與值 | 原始資料 | Agent (readonly) | KPI 計算服務 |
| Logs | 操作紀錄 | 業務資料 | 審計系統 | 所有服務（只能追加） |

---

## 責任邊界與「不能越權」

### 為什麼要劃定責任邊界？

**類比**：在醫院裡，護理師不能開處方，藥師不能做手術。不是因為他們不聰明，而是因為**職責分離是安全的基礎**。

### 越權矩陣

```
✅ 合法操作                    ❌ 越權操作
──────────                    ──────────
Agent 透過工具查詢 DB           Agent 直接寫 SQL
RAG 回傳文件片段+引用           RAG 自己編造內容
Automation 按流程建立工單        Automation 自動關閉工單
User Layer 顯示結果             User Layer 快取敏感資料
```

### 職責分離原則

```
原則 1：垂直分離（Layer Separation）
  每一層只和相鄰層溝通
  User Layer ←→ Orchestrator ←→ Services ←→ Data
  ❌ User Layer 不能直接存取 Data Layer

原則 2：水平分離（Service Separation）
  RAG、MCP Tools、Automation 互不依賴
  一個壞了，另外兩個繼續運作
  ❌ RAG 不能呼叫 MCP Tools

原則 3：讀寫分離（Read/Write Separation）
  AI Agent 預設只能讀取
  寫入操作需要明確授權
  ❌ Agent 不能自己決定要寫入
```

---

## 故障邊界設計

### 故障怎麼擴散？（沒有隔離的情況）

```
RAG 服務超時
  → Orchestrator 等待
    → 使用者看到轉圈圈
      → 使用者重新送出請求
        → 更多請求堆積
          → 整個系統掛掉

這叫做「故障級聯」（Cascading Failure）
```

### 故障怎麼隔離？（有隔離的情況）

```
RAG 服務超時
  → Orchestrator 偵測到超時（3 秒）
    → 啟用降級策略
      → 回覆：「知識庫查詢暫時無法使用，
         以下是根據其他來源的回答... [降級模式]」
    → 同時記錄日誌 + 發送告警

系統繼續運作，使用者得到（降級但有用的）回應
```

### 故障隔離模式

```
模式 1：超時斷路（Circuit Breaker）
┌─────────────────────────────────────┐
│  正常 → 呼叫服務                      │
│  失敗 3 次 → 斷路器打開               │
│  斷路器打開 → 直接回傳降級回應         │
│  30 秒後 → 試探性呼叫                 │
│  成功 → 斷路器關閉，恢復正常           │
└─────────────────────────────────────┘

模式 2：艙壁隔離（Bulkhead）
┌─────────────────────────────────────┐
│  RAG 服務：最多 10 個並行請求         │
│  MCP Tools：最多 5 個並行請求         │
│  Automation：最多 3 個並行請求        │
│                                       │
│  一個服務的流量暴增不會搶走            │
│  其他服務的資源                        │
└─────────────────────────────────────┘

模式 3：降級策略（Graceful Degradation）
┌─────────────────────────────────────┐
│  Level 0：全功能（正常）              │
│  Level 1：RAG 掛 → 用快取知識回答    │
│  Level 2：MCP 掛 → 純知識庫回答      │
│  Level 3：全掛 → 回傳友善錯誤訊息     │
└─────────────────────────────────────┘
```

---

## 資料流圖：一個完整請求的旅程

讓我們追蹤一個完整的請求，看它怎麼在系統中流動：

```
使用者：「根據上季財報，營收成長率如何？跟同業比呢？」

[User Layer]
  │ ① 身份驗證 ✓
  │ ② 請求標準化
  │ ③ 轉發給 Orchestrator
  ▼

[Orchestrator - Planner]
  │ ④ 意圖分析：
  │    - 查詢 KPI（營收成長率）
  │    - 查詢知識庫（財報文件）
  │    - 比較分析（同業對比）
  │ ⑤ 執行計畫：
  │    - 並行呼叫 RAG + KPI 工具
  ▼

[並行執行]
  │
  ├── [RAG] ⑥ 搜尋「上季財報」
  │   └── 回傳：財報摘要 + citation
  │
  ├── [MCP Tool] ⑦ db.kpi("revenue_growth", Q3)
  │   └── 回傳：{ value: 12.5, unit: "%" }
  │
  └── [MCP Tool] ⑧ db.kpi("industry_avg_growth", Q3)
      └── 回傳：{ value: 8.3, unit: "%" }

[Orchestrator - Response Builder]
  │ ⑨ 整合三個來源的結果
  │ ⑩ 加上 citation 和計算過程
  │ ⑪ 格式化回應
  ▼

[User Layer]
  │ ⑫ 顯示結果
  ▼

使用者看到：
  「根據 2025 Q3 財報（kb://financial-report-Q3-2025.pdf, p.15），
   貴公司營收成長率為 12.5%，
   高於同業平均 8.3%（+4.2 個百分點）。
   [來源：db.kpi("revenue_growth"), db.kpi("industry_avg_growth")]」

[Logs]
  ⑬ 記錄完整操作紀錄：
  - 使用者 ID、請求時間
  - 工具呼叫紀錄（3 次）
  - 回應生成時間
  - Token 使用量
```

---

## 動手做：畫你自己的系統藍圖

### 練習 2-1：藍圖繪製

選一個你感興趣的場景（例如：客服機器人、內部知識問答、銷售分析助手），畫出完整的四層架構圖：

```markdown
## 我的系統藍圖

### 場景：___________

### User Layer
- 使用者是誰：
- 介面形式：
- 驗證方式：

### Orchestrator
- 主要意圖類型：
- 需要哪些工具：
- 降級策略：

### Service Layer
- RAG 的知識來源：
- MCP 工具清單：
- 自動化流程：

### Data Layer
- DB 存什麼：
- KB 存什麼：
- KPI 有哪些：
```

### 練習 2-2：故障劇本

為你的系統設計三個故障場景，並寫出處理方式：

| 故障 | 影響範圍 | 偵測方式 | 降級策略 | 復原步驟 |
|------|----------|----------|----------|----------|
| RAG 服務超時 | | | | |
| 資料庫連線斷開 | | | | |
| AI 模型回應異常 | | | | |

### 練習 2-3：資料流追蹤

寫出一個使用者問題，然後像上面的範例一樣，追蹤它在系統中的完整旅程。標記每一步的輸入和輸出。

---

## 本章重點回顧

```
┌─────────────────────────────────────────────┐
│          系統藍圖四大記憶點                     │
│                                               │
│  1. 四層架構：User → Orchestrator →           │
│     Services → Data                           │
│  2. 三大支柱：RAG + MCP Tools + Automation    │
│  3. 責任邊界：每層只做自己的事，不能越權         │
│  4. 故障隔離：一個壞不會拖垮全部               │
└─────────────────────────────────────────────┘
```

---

## 下一章預告

藍圖畫好了，接下來要定規格。

在 [Chapter 3：A2RM 專案權威規格](03-a2rm-spec.md) 中，你會學到：
- 什麼是 A2RM（Agent × RAG × MCP × Automation）
- 一個合格的 AI 系統必須具備哪些能力
- 怎麼用一份規格書定義整個系統

這是整個架構師層的**核心文件**，不能跳過。
