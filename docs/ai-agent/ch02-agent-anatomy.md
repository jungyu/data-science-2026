# Ch02 — Agent 的大腦解剖學

> **「要駕馭一個工具，你必須先理解它的運作方式。」**

---

## 🎯 本章學習目標

讀完這章，你將能夠：

- [ ] 畫出 AI Agent 的完整架構圖
- [ ] 解釋 LLM、工具、記憶三者如何協作
- [ ] 區分 ReAct、Plan-and-Execute 等 Agent 模式
- [ ] 理解 Token 和上下文窗口對 Agent 行為的影響

---

## 如果 Agent 是一個人...

在上一章，我們說 AI Agent 像一個有經驗的裝修師傅。現在讓我們更深入地看看這個「師傅」的大腦是怎麼構造的。

```
┌─────────────────────────────────────────────────┐
│                 AI Agent 的「身體」                │
│                                                   │
│  ┌─────────┐   ┌─────────┐   ┌─────────────────┐│
│  │ 👀 眼睛  │   │ 🧠 大腦  │   │ 🤲 雙手          ││
│  │ (感知層) │──→│ (推理層) │──→│ (執行層)         ││
│  │         │   │         │   │                  ││
│  │ - 讀檔案 │   │ - LLM   │   │ - 寫檔案         ││
│  │ - 看結構 │   │ - 推理   │   │ - 跑命令         ││
│  │ - 搜程式 │   │ - 規劃   │   │ - 呼叫 API       ││
│  └─────────┘   └────┬────┘   └─────────────────┘│
│                      │                            │
│                 ┌────┴────┐                       │
│                 │ 📝 記憶  │                       │
│                 │ (記憶層) │                       │
│                 │         │                       │
│                 │ - 對話   │                       │
│                 │ - 檔案   │                       │
│                 │ - 經驗   │                       │
│                 └─────────┘                       │
└─────────────────────────────────────────────────┘
```

讓我們逐層解剖。

---

## 第一層：大腦 — 大型語言模型（LLM）

### LLM 是什麼？

LLM（Large Language Model）是 Agent 的「大腦」。它是一個經過海量文字訓練的神經網路，能理解和生成人類語言。

```
輸入（你說的話 + 上下文）
        │
        ▼
┌───────────────────────┐
│     大型語言模型        │
│                       │
│  「根據我學過的所有     │
│   程式碼、文件、對話，  │
│   最合理的下一步是...」 │
│                       │
└───────────┬───────────┘
            │
            ▼
輸出（Agent 的回應 + 行動決策）
```

### LLM 的能力與限制

| 能力 | 限制 |
|------|------|
| ✅ 理解自然語言和程式碼 | ❌ 可能產生「幻覺」（編造不存在的 API） |
| ✅ 在數百種語言和框架間切換 | ❌ 知識有截止日期（訓練資料的終點） |
| ✅ 推理複雜的邏輯關係 | ❌ 對長文本的注意力會衰減 |
| ✅ 生成結構化的輸出 | ❌ 不擅長精確計算（數學運算） |
| ✅ 從少量範例中學習模式 | ❌ 無法保證每次輸出一致 |

> 🤔 **如果你問我：「LLM 是 Agent 的全部嗎？」**
>
> 不是。LLM 只是 Agent 的「思考核心」。一個只有 LLM 的系統就像一個只有大腦、沒有手腳的人 ——
> 能思考，但不能行動。Agent 的真正力量來自 LLM + 工具 + 記憶的組合。

---

## 第二層：雙手 — 工具系統（Tool Use）

### 工具讓 Agent 從「嘴砲」變成「實幹」

沒有工具的 LLM：
```
你：「幫我修改 app.js 第 42 行。」
LLM：「好的，你應該把第 42 行改成 ...（印出修改後的程式碼）」
你：（自己複製貼上到檔案中）
```

有工具的 Agent：
```
你：「幫我修改 app.js 第 42 行。」
Agent：*使用 Read 工具讀取 app.js*
       *使用 Edit 工具修改第 42 行*
       「已完成修改。這是變更差異：[diff]」
```

### Agent 常用的工具集

```
┌─────────────────────────────────────────────────┐
│               Agent 的工具箱                      │
│                                                   │
│  📖 閱讀類          ✏️ 編輯類          🔍 搜尋類   │
│  ─────────          ─────────          ─────────  │
│  Read (讀檔案)      Edit (修改檔案)    Grep (搜內容)│
│                     Write (建檔案)     Glob (找檔案)│
│                                                   │
│  🖥️ 執行類          🌐 網路類          📋 管理類   │
│  ─────────          ─────────          ─────────  │
│  Bash (跑命令)      WebSearch          TodoWrite   │
│  Bash (跑測試)      WebFetch           Task (子任務)│
│  Bash (Git 操作)                                   │
└─────────────────────────────────────────────────┘
```

### 工具呼叫的運作原理

Agent 使用工具的過程是這樣的：

```
Step 1: LLM 決定需要使用工具
        「我需要讀取 app.js 來了解目前的程式碼。」

Step 2: LLM 生成工具呼叫請求
        {
          "tool": "Read",
          "parameters": {
            "file_path": "/project/app.js"
          }
        }

Step 3: 系統執行工具，返回結果
        → 檔案內容被回傳給 LLM

Step 4: LLM 根據結果決定下一步
        「好的，我看到第 42 行的問題了。
         現在我要用 Edit 工具來修改...」

Step 5: 回到 Step 1，直到任務完成
```

> 💡 **關鍵洞察**：Agent 的每一步行動都是 LLM「想」出來的。
> 系統不會預先規定「先讀、再改、再測」的順序 ——
> Agent 根據情境**自主決定**使用哪個工具、什麼時候使用。

---

## 第三層：記憶 — 上下文管理

### 為什麼記憶很重要？

想像你和一個失憶的人協作：

```
你：「把函式名稱改成 camelCase。」
Agent（無記憶）：「好的。」*改完了*
你：「順便也改測試檔案裡的引用。」
Agent（無記憶）：「什麼函式？什麼 camelCase？你在說什麼？」
```

記憶讓 Agent 能在整個對話過程中保持連貫。

### Agent 的三種記憶

```
┌─────────────────────────────────────────────────┐
│                                                   │
│  🔵 短期記憶（工作記憶）                            │
│  ════════════════════                              │
│  = 目前這次對話的所有內容                            │
│  = 你說的每句話 + Agent 的每個回應 + 工具結果        │
│  = 受「上下文窗口」限制（例如 200K tokens）          │
│                                                   │
│  🟡 中期記憶（專案記憶）                            │
│  ════════════════════                              │
│  = 專案的 CLAUDE.md 設定檔                          │
│  = 儲存在 .claude/ 目錄的記憶檔案                   │
│  = 跨對話保存，但只在同一專案中有效                  │
│                                                   │
│  🔴 長期記憶（訓練知識）                            │
│  ════════════════════                              │
│  = LLM 訓練時學到的所有知識                         │
│  = 程式語言、框架、最佳實踐、設計模式               │
│  = 固定不變，直到模型更新                           │
│                                                   │
└─────────────────────────────────────────────────┘
```

### 上下文窗口：Agent 的「工作桌面」

上下文窗口就像 Agent 的工作桌面大小。桌面越大，能同時「看到」的資訊越多。

```
上下文窗口 = 200K tokens ≈ 150,000 字 ≈ 500 頁書

┌──────────────────────────────────────────┐
│            上下文窗口 (200K tokens)        │
│                                           │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐  │
│  │ 系統指令  │ │ 對話歷史  │ │ 檔案內容  │  │
│  │ ~5K      │ │ ~50K     │ │ ~100K    │  │
│  └──────────┘ └──────────┘ └──────────┘  │
│                                           │
│  ┌──────────┐ ┌──────────────────────┐   │
│  │ 工具結果  │ │ 🔲 剩餘空間（給回應）  │   │
│  │ ~30K     │ │ ~15K                 │   │
│  └──────────┘ └──────────────────────┘   │
└──────────────────────────────────────────┘
```

> ⚠️ **重要**：當對話太長，早期的內容會被「壓縮」或「遺忘」。
> 這就是為什麼長對話時 Agent 可能「忘記」你一開始說的話。

---

## Agent 的思考模式

不同的 Agent 使用不同的「思考方式」來解決問題。以下是主要的幾種模式：

### 模式一：ReAct（推理 + 行動）

最常見的模式。Agent 交替進行「思考」和「行動」。

```
┌──────────────────────────────────────────┐
│  ReAct 循環                               │
│                                           │
│  思考 → 行動 → 觀察 → 思考 → 行動 → ...  │
│                                           │
│  例子：                                    │
│  🧠 思考：「我需要先看看這個 Bug 在哪裡。」 │
│  ⚡ 行動：Grep 搜尋錯誤訊息                │
│  👀 觀察：「找到了，在 auth.js 第 42 行。」 │
│  🧠 思考：「讓我讀這個檔案看看上下文。」    │
│  ⚡ 行動：Read auth.js                     │
│  👀 觀察：「原來是空指標問題。」            │
│  🧠 思考：「我知道怎麼修了。」              │
│  ⚡ 行動：Edit auth.js                     │
│  ✅ 完成                                   │
└──────────────────────────────────────────┘
```

**優點**：靈活、適應性強，適合探索性任務
**缺點**：每一步都要「想」，Token 消耗較高

### 模式二：Plan-and-Execute（先規劃再執行）

Agent 先制定完整計畫，再按計畫執行。

```
┌──────────────────────────────────────────┐
│  Plan-and-Execute 流程                    │
│                                           │
│  ┌─────────────────────┐                 │
│  │ 📋 規劃階段           │                 │
│  │                      │                 │
│  │ 1. 分析需求           │                 │
│  │ 2. 識別相關檔案       │                 │
│  │ 3. 確定修改順序       │                 │
│  │ 4. 預測風險點         │                 │
│  └──────────┬──────────┘                 │
│             │                             │
│             ▼                             │
│  ┌─────────────────────┐                 │
│  │ ⚡ 執行階段           │                 │
│  │                      │                 │
│  │ 按計畫逐步執行：      │                 │
│  │ Step 1 ✅             │                 │
│  │ Step 2 ✅             │                 │
│  │ Step 3 ⚠️ 遇到問題    │ → 重新規劃      │
│  │ Step 4 ✅             │                 │
│  └─────────────────────┘                 │
└──────────────────────────────────────────┘
```

**優點**：結構化、可預測、適合大型任務
**缺點**：初始規劃需要更多時間

### 模式三：工具鏈（Tool Chaining）

特定任務用特定的工具組合來完成。

```
需求分析 ──→ 程式碼搜尋 ──→ 檔案讀取 ──→ 修改 ──→ 測試
  │              │              │           │         │
  Grep          Glob          Read        Edit      Bash
```

**優點**：高效、低 Token 消耗
**缺點**：靈活性較低

> 💡 **實務中**：現代 Agent（如 Claude Code）會根據任務的複雜度
> 自動切換模式 —— 簡單任務用工具鏈，複雜任務用 Plan-and-Execute。

---

## Token 經濟學：Agent 的「能量」

### 什麼是 Token？

Token 是 LLM 處理文字的最小單位。你可以粗略地理解為：

```
英文：1 個 token ≈ 4 個字母 ≈ 0.75 個單字
中文：1 個 token ≈ 1-2 個字
程式碼：變化很大，取決於符號和結構
```

### 為什麼 Token 很重要？

```
每次 Agent 互動的 Token 消耗：

┌─────────────────────────────────────────┐
│ 輸入 Token（你付費的）                    │
│                                          │
│  系統提示詞    ████░░░░░░░░   ~5K        │
│  對話歷史     ████████░░░░  ~50K        │
│  工具結果     ██████░░░░░░  ~30K        │
│  檔案內容     ████████████ ~100K        │
│                                          │
│ 輸出 Token（你也付費的，而且更貴）         │
│                                          │
│  Agent 回應    ████░░░░░░░░   ~5K        │
│  工具呼叫     ██░░░░░░░░░░   ~2K        │
└─────────────────────────────────────────┘
```

### Token 預算指南

| 操作類型 | 目標預算 | 上限 | 範例 |
|---------|---------|------|------|
| 簡單修改 | 5K | 10K | 修正錯字、改一個函式 |
| 中等任務 | 15K | 30K | 修改 3-5 個檔案 |
| 複雜任務 | 30K | 60K | 架構變更、跨模組重構 |
| 研究分析 | 10K | 20K | 方案評估、框架選擇 |

> 💡 **省 Token 的訣竅**：
> 1. 給 Agent 精確的指令，減少來回溝通
> 2. 指定檔案路徑，避免 Agent 全域搜尋
> 3. 一次性提供完整的需求，而不是「擠牙膏」

---

## 把它們組合起來：完整架構

```
┌─────────────────────────────────────────────────────┐
│                                                       │
│  使用者                                               │
│  「幫我新增一個 /api/users 端點。」                     │
│                                                       │
│          │                                            │
│          ▼                                            │
│  ┌──────────────────────────────────────────────┐    │
│  │              Agent 架構                        │    │
│  │                                               │    │
│  │  ┌───────────┐                                │    │
│  │  │  感知層    │  讀取現有 API 結構              │    │
│  │  │  Perceive │  分析路由模式                   │    │
│  │  └─────┬─────┘  查看資料模型                   │    │
│  │        │                                      │    │
│  │        ▼                                      │    │
│  │  ┌───────────┐  ┌────────────┐                │    │
│  │  │  推理層    │  │   記憶層    │                │    │
│  │  │  Reason   │←→│  Memory    │                │    │
│  │  │           │  │            │                │    │
│  │  │ 「現有 API │  │ 「專案用    │                │    │
│  │  │  用 REST   │  │  Express   │                │    │
│  │  │  風格，    │  │  + Prisma  │                │    │
│  │  │  我應該    │  │  + JWT     │                │    │
│  │  │  保持一    │  │  認證。」   │                │    │
│  │  │  致。」    │  │            │                │    │
│  │  └─────┬─────┘  └────────────┘                │    │
│  │        │                                      │    │
│  │        ▼                                      │    │
│  │  ┌───────────┐                                │    │
│  │  │  執行層    │  建立路由檔案                   │    │
│  │  │  Act      │  新增 Controller                │    │
│  │  │           │  建立 Prisma Model              │    │
│  │  │           │  撰寫測試                       │    │
│  │  └───────────┘  更新路由索引                   │    │
│  │                                               │    │
│  └──────────────────────────────────────────────┘    │
│                                                       │
│          │                                            │
│          ▼                                            │
│  Agent：「完成。我新增了以下檔案：                      │
│          - routes/users.js                            │
│          - controllers/userController.js              │
│          - prisma/schema 更新                          │
│          - tests/users.test.js                        │
│          所有測試通過。」                               │
│                                                       │
└─────────────────────────────────────────────────────┘
```

---

## Agent 的「個性」：System Prompt

每個 Agent 都有一個「個性設定」，稱為 System Prompt。它決定了 Agent 的行為方式。

```
┌──────────────────────────────────────────┐
│  System Prompt（Agent 的個性）             │
│                                           │
│  「你是一位資深全端工程師。                 │
│   你偏好：                                 │
│   - TypeScript 而非 JavaScript            │
│   - 函式式程式設計                         │
│   - 小函式 + 組合模式                      │
│   - 防禦式程式設計                         │
│                                           │
│   你的規則：                               │
│   - 不使用 any 型別                        │
│   - 不跳過測試                             │
│   - 不使用 force push                     │
│   - 修改超過 5 個檔案要先提出計畫」         │
│                                           │
└──────────────────────────────────────────┘
```

這就是我們在後面章節會深入討論的「治理」——
透過精心設計的 System Prompt 和規則，塑造 Agent 的行為。

---

## 常見誤解

### ❌ 「Agent 有自己的意志」

**事實**：Agent 沒有意志、慾望或情感。它的每一個「決策」都是統計模型的輸出。
當 Agent 說「我認為應該...」時，它只是在生成最可能的回應。

### ❌ 「Agent 能記住所有東西」

**事實**：Agent 的記憶受限於上下文窗口。超過窗口大小的資訊會被壓縮或遺忘。
長期記憶需要額外的機制（檔案系統、向量資料庫等）。

### ❌ 「Agent 理解程式碼的含義」

**事實**：Agent 辨識模式和結構，但不像人類那樣「理解」程式碼的業務含義。
它不知道你的電商系統為什麼要對超過 10 萬元的訂單加收手續費。

### ❌ 「更貴的模型一定更好」

**事實**：選擇模型要看任務。簡單的程式碼格式化不需要最強的模型，
但複雜的架構分析則需要更強的推理能力。匹配任務與模型才是最佳策略。

---

## 章末練習

### 🧪 動手做

1. **畫架構圖**：在紙上畫出 AI Agent 的四層架構（感知、推理、行動、記憶），
   並用自己的話標註每層的功能。

2. **Token 估算**：打開你的一個專案，估算主要檔案的 Token 數
   （中文約 1-2 token/字，英文約 0.25 token/字）。
   Agent 一次能「看完」你的整個專案嗎？

3. **模式辨識**：觀察你使用 AI 工具的過程，辨識它屬於哪種思考模式
   （ReAct？Plan-and-Execute？Tool Chaining？）

### 🤔 思考題

1. 為什麼 Agent 需要「工具」而不能直接操作系統？（提示：安全性）
2. 如果上下文窗口無限大，Agent 還需要記憶系統嗎？
3. ReAct 和 Plan-and-Execute 各自適合什麼類型的任務？

---

## 關鍵概念回顧

| 概念 | 一句話總結 |
|------|-----------|
| LLM | Agent 的大腦，負責理解語言和推理 |
| Tool Use | Agent 的雙手，讓它能讀寫檔案和執行命令 |
| 上下文窗口 | Agent 的工作桌面大小，決定能同時處理多少資訊 |
| ReAct | 思考-行動交替的 Agent 模式 |
| Plan-and-Execute | 先規劃再執行的 Agent 模式 |
| Token | Agent 處理的基本單位，也是成本計算的基礎 |
| System Prompt | 定義 Agent 行為和規則的設定 |

---

> **下一章預告**：[Ch03 — 你的第一個 Agent 助手](ch03-first-agent.md)
>
> 理論夠了，是時候動手了！下一章我們將一步步設定你的第一個 AI Agent，
> 並完成一個真實的開發任務。
