# Ch04 — 提示工程：與 Agent 溝通的藝術

> **「問對問題，比找到答案更重要。」**

---

## 🎯 本章學習目標

讀完這章，你將能夠：

- [ ] 寫出結構化的 Agent 指令
- [ ] 使用角色設定提升 Agent 的專業度
- [ ] 掌握分步驟引導的技巧
- [ ] 避免常見的提示工程錯誤

---

## 為什麼提示工程很重要？

同樣一個任務，不同的提示會得到天差地遠的結果：

### 對比實驗

**提示 A**（模糊）：
```
幫我寫一個登入功能。
```

Agent 可能的回應：
```
（生成一個基本的 HTML 表單 + 簡單的密碼比對）
- 沒有加密
- 沒有驗證
- 沒有錯誤處理
- 和你的專案風格完全不同
```

**提示 B**（結構化）：
```
幫我在 src/api/auth.ts 中實作登入端點。

要求：
1. POST /api/auth/login
2. 接收 { email, password }
3. 用 bcrypt 比對密碼
4. 成功回傳 JWT token（有效期 24h）
5. 失敗回傳 401 + 錯誤訊息
6. 請參考 src/api/users.ts 的程式碼風格
7. 先告訴我計畫再動手
```

Agent 的回應：
```
（生成一個完整、安全、風格一致的登入端點）
- bcrypt 密碼比對
- JWT 簽發
- 輸入驗證
- 統一的錯誤處理
- 符合專案慣例
```

> 💡 **關鍵差異**：提示 B 多花了 30 秒寫指令，但省了 30 分鐘的來回修改。

---

## 提示工程的五個層次

```
Level 5  ┌──────────────────────┐
系統級     │ System Prompt 設計    │  ← CLAUDE.md、治理框架
         ├──────────────────────┤
Level 4  │ 工作流程編排          │  ← Slash Command、多步驟
         ├──────────────────────┤
Level 3  │ 結構化指令            │  ← 模板、約束、範例
         ├──────────────────────┤
Level 2  │ 上下文增強            │  ← 檔案參考、背景資訊
         ├──────────────────────┤
Level 1  │ 基本溝通              │  ← 清晰的自然語言
         └──────────────────────┘
```

讓我們逐層攻破。

---

## Level 1：基本溝通 — 說清楚你要什麼

### 原則：具體、明確、可執行

```
❌ 模糊：「改善這段程式碼。」
         → Agent 不知道你要改善什麼方面

✅ 具體：「把 src/utils/date.js 中的 formatDate 函式
         從使用 moment.js 改為使用原生 Intl.DateTimeFormat，
         保持相同的輸出格式。」
         → Agent 知道改什麼、怎麼改、改成什麼
```

### 5W1H 框架

| 要素 | 問題 | 範例 |
|------|------|------|
| **What** | 要做什麼？ | 新增一個使用者註冊端點 |
| **Where** | 在哪裡做？ | src/api/auth.ts |
| **Why** | 為什麼要做？ | 目前只有第三方登入，需要支援 email 註冊 |
| **When** | 什麼條件觸發？ | 當使用者提交 email + password 時 |
| **Who** | 給誰用？ | 前端的註冊表單會呼叫這個 API |
| **How** | 怎麼做？ | 用 bcrypt 加密密碼，存入 PostgreSQL |

你不需要每次都回答所有 6 個問題，但回答越多，結果越精確。

---

## Level 2：上下文增強 — 讓 Agent 看到全貌

### 技巧 1：指定參考檔案

```
請參考 src/api/users.ts 的風格，在同目錄下新增 auth.ts。
```

Agent 會先讀取 users.ts，學習你的：
- 命名慣例
- 錯誤處理模式
- 回應格式
- 匯入風格

### 技巧 2：提供背景資訊

```
背景：
- 這是一個 B2B SaaS 平台
- 使用者分為 admin 和 member 兩個角色
- 我們用 Supabase Auth 處理認證
- 前端是 Next.js 14 (App Router)

任務：
新增一個 admin 邀請成員的功能。
```

### 技巧 3：說明現有的決策

```
我們之前決定用 JWT 而不是 Session，因為：
1. 需要支援多個子域名
2. 前端是 SPA，不方便管理 Cookie
3. 未來需要支援 Mobile App

基於這個決策，請實作 token 刷新機制。
```

> 💡 **為什麼上下文這麼重要？**
>
> Agent 的推理能力很強，但它不知道你的**業務邏輯**。
> 你給的上下文越充分，Agent 的決策就越符合你的需求。

---

## Level 3：結構化指令 — 用模板提高品質

### 功能需求模板

```markdown
## 功能：[名稱]

### 目標
[一句話描述這個功能的目的]

### 規格
- 端點：[HTTP 方法 + 路徑]
- 輸入：[參數及型別]
- 輸出：[回應格式]
- 錯誤處理：[錯誤代碼及情境]

### 約束
- [技術約束]
- [業務規則]
- [效能需求]

### 參考
- 相似功能：[已存在的檔案]
- 文件：[相關文件連結]

### 驗收條件
- [ ] [條件 1]
- [ ] [條件 2]
```

### 實際應用

```
## 功能：密碼重設 API

### 目標
讓使用者透過 email 重設密碼

### 規格
- POST /api/auth/forgot-password
  - 輸入：{ email: string }
  - 輸出：{ message: "重設郵件已發送" }

- POST /api/auth/reset-password
  - 輸入：{ token: string, newPassword: string }
  - 輸出：{ message: "密碼已更新" }

### 約束
- Reset token 有效期 1 小時
- 密碼最少 8 字元，需包含大小寫 + 數字
- 同一 email 每 5 分鐘最多發送 1 次
- 使用 crypto.randomUUID() 生成 token

### 參考
- 相似功能：src/api/auth/login.ts
- 郵件發送：src/services/email.ts

### 驗收條件
- [ ] 能成功發送重設郵件
- [ ] Token 過期後無法重設
- [ ] 密碼驗證規則生效
- [ ] Rate limiting 生效
```

---

## Level 4：工作流程編排 — 多步驟任務

### 技巧 1：分階段指令

對於複雜任務，把它拆成多個階段：

```
# 階段 1：分析
先分析目前 src/auth/ 目錄下所有檔案的職責和依賴關係，
用表格列出每個檔案的功能。

# （審閱後）

# 階段 2：規劃
根據分析結果，規劃認證系統的重構方案。
列出要修改的檔案和順序，以及每步的風險評估。

# （審閱後）

# 階段 3：執行
按照計畫逐步執行。每完成一個檔案的修改，
跑一次測試確認沒有回歸問題。
```

### 技巧 2：Slash Command

Claude Code 支援自訂的 Slash Command，可以封裝常用的工作流程：

```
agent-init/prompts/commands/ 目錄結構：

/specify  →  從自然語言生成規格文件
/clarify  →  澄清規格中的模糊點
/plan     →  制定實作計畫
/analyze  →  跨檔案一致性檢查
/tasks    →  生成依賴排序的任務清單
/implement → 按計畫執行實作
```

使用範例：

```
> /specify 使用者可以透過 email 重設密碼

Agent 會自動：
1. 提取需求中的關鍵實體
2. 生成結構化的規格文件
3. 標記模糊項（需要澄清的地方）
4. 寫入 docs/specs/ 目錄
```

---

## Level 5：系統級提示 — CLAUDE.md 設計

### 從「單次指令」到「持久規則」

與其每次都重複「用 TypeScript」、「不要用 any」，
不如把這些寫進 CLAUDE.md，一勞永逸。

```
每次對話的指令 ──→ 重複、容易遺漏

CLAUDE.md 的規則 ──→ 一次設定，永久生效
```

### CLAUDE.md 的設計原則

```
┌─────────────────────────────────────────────┐
│  好的 CLAUDE.md                               │
│                                               │
│  ✅ 具體可執行的規則                           │
│     「commit message 使用 Conventional         │
│      Commits 格式」                            │
│                                               │
│  ✅ 有明確的理由                               │
│     「不使用 any 型別（因為我們啟用了           │
│      strict mode）」                           │
│                                               │
│  ✅ 有優先順序                                 │
│     「安全性 > 效能 > 可讀性」                  │
│                                               │
│  ✅ 有具體的範例                               │
│     「錯誤回應格式：                            │
│      { error: { code: 'AUTH_001',              │
│        message: '...' } }」                    │
├─────────────────────────────────────────────┤
│  差的 CLAUDE.md                               │
│                                               │
│  ❌ 太模糊                                    │
│     「寫好的程式碼」                            │
│                                               │
│  ❌ 太嚴格                                    │
│     「每個函式不得超過 5 行」                    │
│                                               │
│  ❌ 自相矛盾                                  │
│     「最佳化效能」+「不使用快取」               │
│                                               │
│  ❌ 太長太雜                                   │
│     （超過 500 行的 CLAUDE.md 會浪費 Token）    │
└─────────────────────────────────────────────┘
```

---

## 常見提示模式

### 模式 1：角色扮演

```
假設你是一位有 15 年經驗的資安工程師，
審閱 src/api/ 目錄下所有端點的安全性。
特別注意：
- SQL Injection
- XSS
- CSRF
- 認證繞過
```

**為什麼有效**：角色設定讓 Agent 聚焦在特定視角，提高分析深度。

### 模式 2：正反對比

```
請用兩種方式實作快取機制：

方案 A：使用 Redis
方案 B：使用記憶體快取（Map）

對比它們的：
- 效能差異
- 記憶體使用
- 複雜度
- 適用場景

然後推薦一個方案，並說明理由。
```

**為什麼有效**：強迫 Agent 考慮多個方案，避免「第一個想到的就是最好的」偏見。

### 模式 3：漸進式細化

```
第一輪：「列出這個專案可能的效能瓶頸。」

第二輪：「深入分析第 3 點（資料庫查詢），
         特別是 N+1 查詢問題。」

第三輪：「針對你找到的 N+1 問題，
         用 Prisma 的 include 語法修復它。」
```

**為什麼有效**：像漏斗一樣，從廣到窄，每一步都在前一步的基礎上深入。

### 模式 4：約束反轉

```
不要告訴我怎麼做，先告訴我這個修改可能會出什麼問題。
列出至少 5 個風險點，然後針對每個風險提出緩解策略。
```

**為什麼有效**：逆向思考能發現正向思維容易忽略的盲點。

### 模式 5：範例驅動

```
我希望 API 的錯誤回應格式如下：

成功範例：
{
  "data": { "id": 1, "name": "Alice" },
  "error": null,
  "meta": { "requestId": "abc-123" }
}

錯誤範例：
{
  "data": null,
  "error": {
    "code": "AUTH_001",
    "message": "Token 已過期"
  },
  "meta": { "requestId": "abc-124" }
}

請用這個格式來實作所有的 API 端點回應。
```

**為什麼有效**：一個好的範例勝過一百句描述。Agent 能從範例中精確地推斷出你的期望。

---

## 常見錯誤與修正

### 錯誤 1：一次要求太多

```
❌ 「幫我重構整個專案、加上測試、改善效能、
     更新文件、並且設定 CI/CD。」

✅ 「讓我們分步進行。先從重構 src/utils/ 開始，
     這個目錄有什麼問題？」
```

### 錯誤 2：缺乏退出條件

```
❌ 「持續改善這段程式碼直到完美。」
   → Agent 會無限循環

✅ 「改善這段程式碼，目標是：
     1. 消除所有 TypeScript 型別錯誤
     2. 把函式拆分到各自的檔案
     3. 確保測試覆蓋率 > 80%」
```

### 錯誤 3：假設 Agent 記得一切

```
❌ （在第 50 輪對話時）
   「用我們之前討論的方案來修改。」

✅ 「用 JWT + Redis 快取的方案來修改 auth middleware。
     具體來說：[重述關鍵決策]」
```

### 錯誤 4：忽略 Agent 的反饋

```
❌ Agent：「這個修改可能會影響 3 個相依模組，建議先...」
   你：「不用管，直接改。」

✅ Agent：「這個修改可能會影響 3 個相依模組，建議先...」
   你：「好的，請列出受影響的模組和影響方式，
        我們一個一個處理。」
```

---

## 提示工程速查表

```
┌──────────────────────────────────────────────────┐
│              提示工程速查表                         │
│                                                    │
│  📋 結構化指令                                     │
│  ─────────────                                     │
│  1. 說明目標（What + Why）                         │
│  2. 指定位置（Where）                              │
│  3. 列出約束（How + 限制）                         │
│  4. 給出範例（Example）                            │
│  5. 定義驗收（Done = ?）                           │
│                                                    │
│  🎯 效果提升技巧                                   │
│  ─────────────                                     │
│  - 「先規劃再執行」      → 減少返工                │
│  - 「參考 @<file>」      → 保持風格一致            │
│  - 「為什麼選這個方案？」 → 強迫深度思考            │
│  - 「列出風險」          → 預防問題                 │
│  - 「用表格比較」        → 結構化輸出               │
│                                                    │
│  ⚠️ 避免的錯誤                                     │
│  ─────────────                                     │
│  - 一次要求太多                                    │
│  - 缺乏明確的完成條件                              │
│  - 假設 Agent 記得所有歷史                          │
│  - 忽略 Agent 的警告                               │
│  - 不指定範圍就說「改善」                           │
└──────────────────────────────────────────────────┘
```

---

## 章末練習

### 🧪 動手做

1. **提示改寫**：找一個你之前給 AI 工具的模糊提示，用本章學到的技巧重寫它。
   比較兩次的結果差異。

2. **模板實作**：用「功能需求模板」寫一個你專案中需要實作的功能需求，
   然後交給 Agent 執行。

3. **角色實驗**：讓 Agent 分別以「資安工程師」和「效能工程師」的角色
   審閱同一段程式碼，比較它們關注的重點有何不同。

### 🤔 思考題

1. 為什麼「範例」比「描述」更有效？
2. 在什麼情況下，過於詳細的指令反而會降低效果？
3. 如果你要教一個新人寫提示詞，你會先教哪三個技巧？

---

## 關鍵概念回顧

| 概念 | 一句話總結 |
|------|-----------|
| 5W1H | 用 What/Where/Why/When/Who/How 框架構建完整指令 |
| 上下文增強 | 給 Agent 越多相關背景，結果越好 |
| 結構化模板 | 用固定格式確保不遺漏重要資訊 |
| 工作流程編排 | 複雜任務拆成多階段，逐步推進 |
| 系統級提示 | 用 CLAUDE.md 固化長期有效的規則 |

---

> **下一章預告**：[Ch05 — SDD × BDD × TDD 工作流](ch05-sdd-bdd-tdd.md)
>
> 你已經學會如何和 Agent 溝通了。下一章我們將進入真正的「Agent 驅動開發」——
> 一套完整的規格導向 + 行為導向 + 測試導向的開發工作流。
