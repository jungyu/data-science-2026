# Ch07 — 治理憲法：給 Agent 一部基本法

> **「權力越大，約束越重要。」**

---

## 🎯 本章學習目標

讀完這章，你將能夠：

- [ ] 解釋為什麼 Agent 需要「憲法」
- [ ] 設計一套適合自己專案的治理原則
- [ ] 理解四層防護體系的架構
- [ ] 撰寫你的第一份 constitution.md

---

## 從「好用」到「可靠」

在前面的章節中，我們學會了如何使用 Agent、如何和它溝通、如何用工具完成任務。
但有一個關鍵問題還沒回答：

> **「我怎麼確保 Agent 不會搞砸？」**

### 一個真實場景

```
週五晚上 11 點，你讓 Agent 修一個「小 Bug」。

Agent 的內心獨白：
「這個 Bug 的根因在 DB Schema...
 讓我順便修一下... 改了 Schema 就要改 ORM...
 改了 ORM 就要改所有的 Repository...
 改了 Repository 就要改 Service 層...
 啊，有些舊的測試也要改...
 這些舊測試看起來沒用了，刪掉吧...」

結果：
✅ Bug 修好了
❌ 但同時修改了 27 個檔案
❌ 刪除了 15 個「看起來沒用」的測試
❌ DB Migration 沒有寫 rollback
❌ 週一早上整個 staging 環境壞了
```

這就是為什麼我們需要「治理」。

---

## 四層防護體系

治理不是一條規則，而是一個**多層防禦系統**。

```
┌─────────────────────────────────────────────────┐
│                                                   │
│  L0  原則層 — Constitution（不可妥協）             │
│  ═══════════════════════════════════              │
│  「永遠先寫測試」「永遠不 force push main」         │
│                                                   │
│  L1  決策層 — Decision Diary（臨時 → 正式）       │
│  ═══════════════════════════════════              │
│  「我們決定用 JWT 因為需要跨域支援」               │
│                                                   │
│  L2  操作層 — Human Review（需人類確認）           │
│  ═══════════════════════════════════              │
│  「修改 DB Schema 前必須停下來請我確認」           │
│                                                   │
│  L3  語意層 — Semantic Deny（絕對禁止）            │
│  ═══════════════════════════════════              │
│  「絕對不使用 @ts-ignore」「絕對不硬編碼密鑰」     │
│                                                   │
└─────────────────────────────────────────────────┘
```

每一層都在不同層面保護你的專案：

| 層級 | 保護的是 | 比喻 |
|------|---------|------|
| L0 原則 | 根本方向 | 國家的憲法 |
| L1 決策 | 技術選擇 | 政府的政策 |
| L2 操作 | 危險動作 | 重要文件需要主管簽名 |
| L3 語意 | 程式碼品質 | 工廠的安全規程 |

---

## L0：憲法原則（Constitution）

### 什麼是「不可妥協」的原則？

憲法原則是**無論如何都不能違反**的規則。即使時間很趕、需求很急，也不能跳過。

### 五大原則

參考 `agent-init/memory/constitution.md`：

#### 原則一：測試優先（Test-First Development）

```
規則：
- 任何新功能必須先寫測試
- 修 Bug 必須先寫一個能重現 Bug 的測試
- 不得刪除現有測試（除非功能已被移除）
- 測試覆蓋率不得低於 80%

為什麼不可妥協？
→ 沒有測試的程式碼 = 定時炸彈
→ 「先寫完再補測試」= 永遠不會補
```

#### 原則二：型別安全（Type Safety First）

```
規則：
- 禁止使用 any 型別
- 啟用 strict mode
- 所有公開 API 必須有完整的型別定義

為什麼不可妥協？
→ any 型別 = 關閉型別檢查 = 回到 JavaScript 時代
→ 型別是最好的文件
```

#### 原則三：安全優先（Security by Default）

```
規則：
- 所有使用者輸入必須驗證和消毒
- 密碼使用 bcrypt/argon2 加密，永不明文
- API 金鑰存在環境變數，不進 Git
- 預設啟用 CORS 限制

為什麼不可妥協？
→ 安全漏洞的修復成本 >> 預防成本
→ 一次資料外洩可以毀掉一間公司
```

#### 原則四：程式碼品質（Code Quality）

```
規則：
- Linting 零警告
- 遵循專案的命名慣例
- 單一職責：一個函式做一件事
- 不超過 500 行 / 檔案

為什麼不可妥協？
→ 程式碼被讀的次數 >> 被寫的次數
→ 維護成本佔軟體生命週期的 60-80%
```

#### 原則五：Git 紀律（Git Discipline）

```
規則：
- 使用 Conventional Commits 格式
- 禁止 force push 到 main/master
- 每個 PR 附帶測試
- 有意義的 commit message

為什麼不可妥協？
→ Git 歷史 = 專案的記憶
→ force push = 抹除歷史
```

---

## 如何撰寫你的 Constitution

### 步驟一：識別你的核心價值

問自己：
```
1. 如果明天專案出了大問題，最可能是什麼？
   → 那就是你最需要的原則

2. 哪些錯誤一旦犯了就很難修復？
   → 那些需要成為不可妥協的原則

3. 你最不想在 code review 中看到什麼？
   → 那些需要成為禁止規則
```

### 步驟二：撰寫原則

每個原則包含四個部分：

```markdown
## Principle [N]: [名稱]

### 規則
- [具體、可執行的規則]
- [用「必須」和「禁止」而非「應該」和「建議」]

### 理由
[為什麼這個原則不可妥協？]

### 實施
[如何檢查是否遵守？]

### 例外
[如果有合理例外，明確列出]
（最好沒有例外）
```

### 步驟三：建立 constitution.md

在你的專案中建立 `memory/constitution.md` 或寫進 `CLAUDE.md`：

```markdown
# 專案憲法

> 以下原則不可妥協，無論截止日期或需求壓力。

## Principle I: 測試優先
- 新功能 → 先寫測試
- Bug 修復 → 先重現 Bug
- 刪除測試 → 需人類確認

## Principle II: 型別安全
- 禁止 any
- strict mode 永遠開啟
- 公開 API 必須有型別

## Principle III: 安全優先
- 輸入驗證：永遠
- 密碼加密：bcrypt
- 密鑰管理：env only

## Principle IV: 品質標準
- Lint 零警告
- 單一職責
- 單檔 ≤ 500 行

## Principle V: Git 紀律
- Conventional Commits
- 禁止 force push main
- PR 附帶測試
```

---

## 原則的升級路徑

不是所有規則都是一開始就確定的。有些規則需要從「決策」逐步「升級」為「原則」。

```
觀察 → 假設 → 嘗試 → 驗證 → 決策 → 原則

                  Decision Diary          Constitution
                  (L1 決策層)              (L0 原則層)
                       │                       │
                       ▼                       │
例子：                                         │
「JWT 似乎比 Session 適合」──→ 試用 2 週 ──→  │
「確認 JWT 在跨域場景更好」──→ 寫入 diary ──→ │
「全團隊都認同 JWT 策略」 ──→ ────────────────→ 升級為原則
```

> 💡 **關鍵洞察**：憲法不是一天寫完的。它是透過實踐不斷演化的。
> 剛開始可能只有 2-3 條原則，隨著專案成熟，逐步增加。

---

## 漸進式採用策略

### 第一階段：Minimal（2 小時）

```
只需要：
✅ constitution.md（3-5 條核心原則）
✅ 基本的 CLAUDE.md（技術堆疊 + 編碼規範）

適合：個人專案、原型開發
```

### 第二階段：Standard（1-2 天）

```
在 Minimal 的基礎上加：
✅ Decision Diary（記錄技術決策）
✅ Human Review Triggers（定義哪些操作需人類確認）
✅ 2-3 個 Governance Gates

適合：團隊專案、正式產品
```

### 第三階段：Full（漸進建立）

```
在 Standard 的基礎上加：
✅ Token 預算管理
✅ 任務管理系統
✅ 操作日誌
✅ 完整的規格範本
✅ 模組級規則

適合：大型專案、企業級系統
```

---

## 常見問題

### 「這會不會限制 Agent 的能力？」

```
不會。就像交通規則不會限制你到達目的地的能力，
但能確保你安全到達。

比喻：
- 沒有規則的 Agent = 沒有交通規則的高速公路
  → 很「自由」，但很危險
- 有規則的 Agent = 有交通規則的高速公路
  → 稍有約束，但更快更安全地到達目的地
```

### 「原則太多怎麼辦？」

```
原則不是越多越好。好的憲法應該是：
- 3-7 條核心原則（太少不夠用，太多記不住）
- 每條都有明確的理由
- 每條都可以驗證（不是空泛的口號）

如果超過 7 條，考慮：
- 是否有些可以合併？
- 是否有些其實是「建議」而非「原則」？
- 是否有些應該降級到 L1 決策層？
```

### 「團隊成員不同意某個原則怎麼辦？」

```
原則的制定應該是民主的，但遵守應該是強制的。

流程：
1. 提出新原則 + 理由
2. 團隊討論（設時限，如 1 週）
3. 投票或達成共識
4. 一旦通過，所有人（包括 Agent）都必須遵守
5. 如果需要修改，走同樣的流程
```

---

## 章末練習

### 🧪 動手做

1. **識別原則**：回顧你最近的 3 個 Bug，分析它們是否可以被某個原則預防。
   把這些原則寫下來。

2. **撰寫憲法**：為你的專案寫一份 `constitution.md`，包含 3-5 條原則。
   每條原則必須有：規則、理由、實施方式。

3. **升級演練**：回顧你最近做的一個技術決策，
   評估它是否適合從「決策」升級為「原則」。

### 🤔 思考題

1. 「所有使用者輸入都必須驗證」是一個好的憲法原則嗎？為什麼？
2. 什麼時候一個「原則」應該被降級或移除？
3. 如果一個原則在 90% 的情況下有益，但在 10% 的情況下造成麻煩，
   它還應該是「不可妥協」的嗎？

---

## 關鍵概念回顧

| 概念 | 一句話總結 |
|------|-----------|
| 四層防護 | L0 原則 → L1 決策 → L2 操作 → L3 語意，層層防護 |
| Constitution | 不可妥協的核心原則，專案的基本法 |
| 漸進式採用 | Minimal → Standard → Full，按需成長 |
| 原則升級 | 從決策到原則有明確的驗證和升級路徑 |

---

> **下一章預告**：[Ch08 — 紅線與護欄：語意禁止與人類審查](ch08-rules-and-boundaries.md)
>
> 憲法定義了「大方向」，但我們還需要具體的「紅線」——
> 哪些程式碼絕對不能寫？哪些操作必須人類確認？
