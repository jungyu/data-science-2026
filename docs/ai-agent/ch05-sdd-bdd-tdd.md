# Ch05 — SDD × BDD × TDD：Agent 驅動開發工作流

> **「好的軟體不是一次寫對的，而是一步步從規格走到程式碼的。」**

---

## 🎯 本章學習目標

讀完這章，你將能夠：

- [ ] 解釋 SDD、BDD、TDD 各自的角色與關聯
- [ ] 使用四問題評估法判斷功能複雜度
- [ ] 按照「規格 → 情境 → 測試 → 程式碼」的流程開發
- [ ] 根據複雜度選擇 Lite / Standard / Full 工作流

---

## 為什麼需要結構化的開發流程？

### 沒有流程的 Agent 開發

```
你：「幫我做使用者登入功能。」
Agent：（直接開始寫程式碼）
      → 寫了 500 行，但忘了 rate limiting
      → 密碼驗證規則和 PM 想的不一樣
      → 測試覆蓋率只有 30%
      → 三天後才發現少了「忘記密碼」

結果：程式碼有了，但品質堪憂，需要大量返工。
```

### 有流程的 Agent 開發

```
你：「/specify 使用者登入功能」
Agent：（生成結構化規格）

你：「/clarify」
Agent：（問 5 個關鍵問題，消除模糊）

你：「/plan」
Agent：（制定實作計畫，包含風險評估）

你：「/tasks」
Agent：（生成依賴排序的任務清單）

你：「/implement」
Agent：（按任務清單逐步執行，每步驗證）

結果：品質可控，不會遺漏，每步有驗證。
```

---

## 三個 D 的角色分工

```
┌──────────────────────────────────────────────────┐
│                                                    │
│  SDD                    BDD                  TDD   │
│  Spec-Driven           Behavior-Driven      Test   │
│  Development           Development        -Driven  │
│                                          Dev.      │
│  ┌──────────┐      ┌──────────┐      ┌──────────┐│
│  │ 📋 規格   │  →   │ 🎭 情境   │  →   │ ✅ 測試   ││
│  │          │      │          │      │          ││
│  │ 定義     │      │ 描述     │      │ 驗證     ││
│  │ 「做什麼」│      │ 「怎麼用」│      │ 「對不對」││
│  │          │      │          │      │          ││
│  │ What     │      │ How      │      │ Verify   ││
│  └──────────┘      └──────────┘      └──────────┘│
│                                                    │
│  產出物：            產出物：            產出物：    │
│  spec.md            feature 檔        test 檔案   │
│  plan.md            Gherkin 語法      unit tests  │
│  tasks.md           驗收情境          integration  │
│                                       tests       │
└──────────────────────────────────────────────────┘
```

### SDD（規格驅動開發）

**核心理念**：在寫任何程式碼之前，先把「要做什麼」寫清楚。

```markdown
## 功能規格：使用者登入

### 使用者場景
1. 使用者在登入頁面輸入 email 和密碼
2. 系統驗證帳號是否存在
3. 系統比對密碼
4. 成功則回傳 JWT token
5. 失敗則回傳錯誤訊息

### 驗收條件
- [ ] email 格式驗證
- [ ] 密碼長度 ≥ 8 字元
- [ ] 錯誤嘗試 5 次後鎖定 15 分鐘
- [ ] JWT 有效期 24 小時
```

### BDD（行為驅動開發）

**核心理念**：用「使用者的語言」描述系統應該如何行為。

```gherkin
Feature: 使用者登入

  Scenario: 成功登入
    Given 一個已註冊的使用者 "alice@example.com"
    When 使用者輸入正確的 email 和密碼
    Then 系統回傳 200 狀態碼
    And 回應中包含有效的 JWT token

  Scenario: 密碼錯誤
    Given 一個已註冊的使用者 "alice@example.com"
    When 使用者輸入錯誤的密碼
    Then 系統回傳 401 狀態碼
    And 回應中包含錯誤訊息 "帳號或密碼錯誤"

  Scenario: 帳號被鎖定
    Given 一個已連續失敗 5 次的使用者
    When 使用者再次嘗試登入
    Then 系統回傳 429 狀態碼
    And 回應中包含剩餘等待時間
```

### TDD（測試驅動開發）

**核心理念**：先寫測試，再寫程式碼。

```javascript
// 先寫測試
describe('POST /api/auth/login', () => {
  test('成功登入回傳 JWT', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({ email: 'alice@example.com', password: 'Pass1234' });

    expect(response.status).toBe(200);
    expect(response.body.data.token).toBeDefined();
  });

  test('密碼錯誤回傳 401', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({ email: 'alice@example.com', password: 'wrong' });

    expect(response.status).toBe(401);
  });
});

// 然後才寫實作程式碼讓測試通過
```

---

## 四問題複雜度評估法

在開始任何功能之前，先回答 4 個問題來判斷複雜度：

```
┌──────────────────────────────────────────────────┐
│           四問題複雜度評估                          │
│                                                    │
│  Q1: 涉及多少模組或服務？                          │
│      □ 1 個 (0 分)    □ 2+ 個 (2 分)              │
│                                                    │
│  Q2: 有權限、並發或不可逆操作嗎？                   │
│      □ 沒有 (0 分)    □ 有 (3 分)                  │
│                                                    │
│  Q3: 涉及 DB Schema 變更嗎？                       │
│      □ 不涉及 (0 分)  □ 涉及 (2 分)               │
│                                                    │
│  Q4: 涉及外部 API 整合嗎？                         │
│      □ 不涉及 (0 分)  □ 涉及 (2 分)               │
│                                                    │
│  ─────────────────────────────────────────────    │
│  總分：_____ 分                                    │
│                                                    │
│  0-2 分 → Lite 工作流      (~800 tokens)          │
│  3-5 分 → Standard 工作流  (~2,000 tokens)        │
│  6+  分 → Full 工作流      (~5,000 tokens)        │
└──────────────────────────────────────────────────┘
```

### 範例評估

| 功能 | Q1 | Q2 | Q3 | Q4 | 總分 | 工作流 |
|------|----|----|----|----|------|--------|
| 修正按鈕顏色 | 0 | 0 | 0 | 0 | **0** | Lite |
| 新增 API 端點 | 2 | 0 | 2 | 0 | **4** | Standard |
| 金流系統整合 | 2 | 3 | 2 | 2 | **9** | Full |

---

## 三種工作流

### Lite 工作流（0-2 分）

適合：簡單的工具函式、樣式修改、錯字修正

```
┌─────────┐   ┌─────────┐   ┌─────────┐
│  需求    │ → │  實作    │ → │  驗證    │
│ (1 句話) │   │ (直接做) │   │ (快速測) │
└─────────┘   └─────────┘   └─────────┘
```

Agent 指令：

```
把 src/utils/format.ts 的 formatDate 函式
輸出格式從 "YYYY-MM-DD" 改成 "YYYY/MM/DD"。
修改後跑一下相關測試。
```

### Standard 工作流（3-5 分）

適合：新功能、元件升級、中等重構

```
┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
│  規格    │ → │  情境    │ → │  計畫    │ → │  實作    │ → │  驗證    │
│ spec     │   │ scenario │   │ plan     │   │ code    │   │ test    │
└─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘
```

Agent 指令序列：

```
# Step 1: 規格
/specify 使用者可以修改個人資料（姓名、大頭貼、簡介）

# Step 2: 情境（Agent 自動從規格中提取）
/clarify  ← 澄清模糊點

# Step 3: 計畫
/plan     ← 生成實作計畫

# Step 4: 實作 + 驗證
/implement ← 按計畫執行，每步測試
```

### Full 工作流（6+ 分）

適合：複雜系統整合、資料庫遷移、金流/認證系統

```
┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐
│ 規格    │ → │ 澄清    │ → │ 研究    │ → │ 計畫    │ → │ 任務    │
│ spec    │   │ clarify │   │ research│   │ plan    │   │ tasks   │
└────────┘   └────────┘   └────────┘   └────────┘   └────┬───┘
                                                          │
    ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐   │
    │ 部署    │ ← │ 整合    │ ← │ 驗證    │ ← │ 實作    │ ←─┘
    │ deploy  │   │ integrate│   │ validate│   │ implement│
    └────────┘   └────────┘   └────────┘   └────────┘
```

完整的 Agent 指令序列：

```
# Phase 0: 規格與澄清
/specify 整合第三方金流 API（綠界 ECPay）
/clarify

# Phase 1: 研究與計畫
「分析綠界 ECPay 的 API 文件，
  列出需要整合的端點和資料結構。」
/plan

# 🛑 人類審查點：確認計畫

# Phase 2: 任務分解
/tasks

# Phase 3: 逐步實作
/implement

# Phase 4: 整合驗證
「跑所有測試，特別是 e2e 測試。
  確認金流流程端對端正常。」
```

---

## 四句咒語：記住工作流的核心

```
┌──────────────────────────────────────────────────┐
│                                                    │
│   📋  /specify  —  「先說清楚要做什麼」             │
│                                                    │
│   🔍  /clarify  —  「把模糊的地方問清楚」           │
│                                                    │
│   🗺️  /plan     —  「畫一張施工藍圖」               │
│                                                    │
│   🔨  /implement — 「按圖施工，步步驗證」           │
│                                                    │
│   記憶口訣：                                       │
│   「說清楚、問明白、畫藍圖、按圖做」               │
│                                                    │
└──────────────────────────────────────────────────┘
```

---

## 實戰範例：從零到完成

### 任務：新增「使用者邀請」功能

#### Step 1：評估複雜度

```
Q1: 涉及 API + Email + DB = 3 個模組 → 2 分
Q2: 邀請涉及權限（只有 admin 能邀請）→ 3 分
Q3: 需要新增 invitations 表 → 2 分
Q4: 不涉及外部 API → 0 分

總分：7 分 → Full 工作流
```

#### Step 2：撰寫規格

```markdown
## 功能規格：使用者邀請系統

### 目標
Admin 可以透過 email 邀請新使用者加入組織

### 使用者場景
1. Admin 輸入被邀請者的 email
2. 系統生成邀請連結，發送邀請信
3. 被邀請者點擊連結，設定密碼完成註冊
4. 被邀請者自動加入該組織

### 邊界條件
- 邀請連結 72 小時內有效
- 已註冊的 email 不能被邀請（顯示提示）
- 同一 email 最多 3 封未使用的邀請
- 只有 admin 角色可以發出邀請
```

#### Step 3：撰寫 BDD 情境

```gherkin
Feature: 使用者邀請

  Background:
    Given 一個已登入的 admin 使用者

  Scenario: 成功發送邀請
    When admin 輸入 "newuser@example.com" 並送出邀請
    Then 系統建立一個狀態為 "pending" 的邀請記錄
    And 發送一封含有邀請連結的 email
    And 回傳 201 狀態碼

  Scenario: 邀請已註冊的使用者
    Given "existing@example.com" 已經是註冊使用者
    When admin 輸入 "existing@example.com" 並送出邀請
    Then 系統回傳 409 狀態碼
    And 回應訊息為 "此 email 已經是註冊使用者"

  Scenario: 非 admin 嘗試邀請
    Given 一個已登入的 member 使用者
    When member 嘗試發送邀請
    Then 系統回傳 403 狀態碼

  Scenario: 邀請連結過期
    Given 一個 72 小時前建立的邀請
    When 被邀請者點擊邀請連結
    Then 系統顯示 "邀請已過期，請聯繫管理員重新邀請"
```

#### Step 4：交給 Agent 執行

```
我已經完成了「使用者邀請」功能的規格和 BDD 情境。
請依據以下步驟實作：

1. 先建立 DB Migration（新增 invitations 表）
2. 實作 API 端點（POST /api/invitations, GET /api/invitations/:token）
3. 實作 Email 發送服務
4. 撰寫單元測試和整合測試
5. 每完成一步，跑測試確認

約束：
- 參考 src/api/users.ts 的程式碼風格
- 使用 Prisma ORM
- 邀請 token 使用 crypto.randomUUID()

先告訴我詳細計畫再開始。
```

---

## 常見陷阱與對策

### 陷阱 1：跳過規格直接寫程式碼

```
問題：Agent 生成的程式碼和需求不符
原因：沒有明確的驗收條件
對策：即使是簡單功能，也至少寫 3 條驗收條件
```

### 陷阱 2：規格寫得太細

```
問題：規格比程式碼還長，浪費 Token
原因：過度規範實作細節
對策：規格描述「做什麼」，不描述「怎麼做」
      實作細節留給 Agent 和程式碼
```

### 陷阱 3：忘記邊界條件

```
問題：功能在正常情況下運作，邊界情況崩潰
原因：BDD 情境只考慮了「快樂路徑」
對策：每個功能至少寫 3 類情境：
      - 正常路徑（happy path）
      - 錯誤路徑（error path）
      - 邊界路徑（edge case）
```

---

## 章末練習

### 🧪 動手做

1. **複雜度評估**：用四問題法評估你專案中 3 個待開發功能的複雜度。

2. **規格撰寫**：選一個 Standard 等級的功能，寫出完整規格，包含：
   - 使用者場景
   - 至少 5 條驗收條件
   - 3 個 BDD 情境（正常/錯誤/邊界）

3. **完整流程**：用 Lite 工作流完成一個簡單功能（從規格到程式碼）。

### 🤔 思考題

1. 為什麼 SDD 強調「先規格後程式碼」？直接寫程式碼有什麼風險？
2. BDD 的 Gherkin 語法有什麼優勢？為什麼不直接寫測試案例？
3. 在什麼情況下，你會把一個看似 Standard 的功能升級為 Full 工作流？

---

## 關鍵概念回顧

| 概念 | 一句話總結 |
|------|-----------|
| SDD | 先寫規格再寫程式碼，確保方向正確 |
| BDD | 用使用者語言描述行為，確保需求被理解 |
| TDD | 先寫測試再寫實作，確保品質達標 |
| 四問題法 | 用 4 個問題快速評估功能複雜度 |
| Lite/Standard/Full | 根據複雜度選擇適當的工作流深度 |
| 四句咒語 | specify → clarify → plan → implement |

---

> **下一章預告**：[Ch06 — 工具與超能力：MCP 與 Tool Use](ch06-tools-and-mcp.md)
>
> Agent 驅動開發的流程有了，但 Agent 的能力不只是讀寫檔案。
> 下一章我們將探索 MCP（Model Context Protocol）—— 一個讓 Agent
> 獲得「超能力」的協議，從查文件到跑瀏覽器測試，無所不能。
